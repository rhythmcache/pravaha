// generate C header and pkg-config when capi feature is enabled
fn main() {
    #[cfg(feature = "capi")]
    {
        generate_c_header();
        generate_pkg_config();
    }
}

#[cfg(feature = "capi")]
fn generate_c_header() {
    use std::env;
    use std::path::PathBuf;
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let output_file = PathBuf::from(&crate_dir).join("pravaha.h");
    println!("cargo:rerun-if-changed=src/ffi.rs");
    println!("cargo:rerun-if-changed=src/core.rs");
    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_include_guard("PRAVAHA_H")
        .with_pragma_once(true)
        .with_documentation(true)
        .with_namespace("pravaha")
        .with_parse_deps(true)
        .with_parse_include(&["libc"])
        .rename_item("PravahaErrorCode", "pravaha_error_code_t")
        .rename_item("PravahaFilesystem", "pravaha_filesystem_t")
        .rename_item("PravahaFile", "pravaha_file_t")
        .with_header(
            "/**\n\
             * Pravaha C API\n\
             * \n\
             * A library for reading HTTP(S) files with chunking, caching, and prefetching.\n\
             * \n\
             * Basic usage:\n\
             * \n\
             *     pravaha_file_t* file = pravaha_open_url(\"https://example.com/data.bin\", \"r\");\n\
             *     if (!file) {\n\
             *         fprintf(stderr, \"Error: %s\\n\", pravaha_last_error());\n\
             *         return 1;\n\
             *     }\n\
             *     \n\
             *     char buffer[1024];\n\
             *     ssize_t n = pravaha_read(file, buffer, sizeof(buffer));\n\
             *     \n\
             *     pravaha_file_close(file);\n\
             * \n\
             * All functions are thread-safe for their error reporting (thread-local storage).\n\
             * Filesystem handles can be shared between threads.\n\
             * File handles should not be used from multiple threads simultaneously.\n\
             */",
        )
        .with_after_include(
            "#include <stdint.h>\n\
             #include <stddef.h>\n\
             \n\
             #ifdef _WIN32\n\
             typedef intptr_t ssize_t;\n\
             #else\n\
             #include <sys/types.h>\n\
             #endif\n\
             \n\
             #ifdef __cplusplus\n\
             extern \"C\" {\n\
             #endif",
        )
        .with_trailer(
            "#ifdef __cplusplus\n\
             }\n\
             #endif",
        )
        .generate()
        .expect("Unable to generate C bindings")
        .write_to_file(&output_file);
    println!(
        "cargo:warning=Generated C header: {}",
        output_file.display()
    );
}

#[cfg(feature = "capi")]
fn generate_pkg_config() {
    use std::env;
    use std::fs;
    use std::path::PathBuf;

    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let out_dir = env::var("OUT_DIR").unwrap();
    let target = env::var("TARGET").unwrap_or_default();
    let is_android = target.contains("android");

    let version = env::var("CARGO_PKG_VERSION").unwrap();
    let description = env::var("CARGO_PKG_DESCRIPTION").unwrap_or_else(|_| {
        "A library for reading HTTP(S) files with chunking, caching, and prefetching".to_string()
    });

    // OUT_DIR is  <workspace>/target/<target-triple>/<profile>/build/<crate>/out
    // The compiled library lands three levels up from OUT_DIR :
    //   <workspace>/target/<target-triple>/<profile>/
    // Walk up: out -> <crate> -> build -> <profile>
    let lib_dir = PathBuf::from(&out_dir)
        .parent()
        .unwrap() // out  -> <crate-hash>
        .parent()
        .unwrap() // <crate-hash> -> build
        .parent()
        .unwrap() // build -> <profile>  (e.g. debug / release)
        .to_path_buf();

    // Header lives next to Cargo.toml (written by generate_c_header)
    let include_dir = PathBuf::from(&crate_dir);

    // -ldl is not needed on Android (Bionic provides it inside libc)
    // -lpthread is folded into Bionic libc on Android as well
    let mut private_libs: Vec<&str> = Vec::new();
    if !is_android {
        private_libs.push("-lpthread");
        private_libs.push("-ldl");
    }
    // -lcurl only when the curl feature is active
    #[cfg(feature = "curl")]
    private_libs.push("-lcurl");

    // use absolute paths so the .pc file works without installing
    // (consumers can always `pkg-config --define-variable=...` to override)
    let pc_content = format!(
        "# pkg-config file for libpravaha\n\
         # Generated by build.rs â€” do not edit manually.\n\
         # Library : {lib_dir}\n\
         # Header  : {include_dir}/pravaha.h\n\
         \n\
         libdir={lib_dir}\n\
         includedir={include_dir}\n\
         \n\
         Name: libpravaha\n\
         Description: {description}\n\
         Version: {version}\n\
         Libs: -L${{libdir}} -lpravaha\n\
         {private}\
         Cflags: -I${{includedir}}\n",
        lib_dir = lib_dir.display(),
        include_dir = include_dir.display(),
        description = description,
        version = version,
        private = if private_libs.is_empty() {
            String::new()
        } else {
            format!("Libs.private: {}\n", private_libs.join(" "))
        },
    );

    let output_file = PathBuf::from(&crate_dir).join("libpravaha.pc");
    fs::write(&output_file, pc_content).expect("Unable to write pkg-config file");
    println!(
        "cargo:warning=Generated pkg-config : {}",
        output_file.display()
    );
    println!("cargo:warning=  libdir             : {}", lib_dir.display());
    println!(
        "cargo:warning=  includedir         : {}",
        include_dir.display()
    );
}
